# noqa: D100
import logging
from dataclasses import dataclass
from typing import Tuple, Union

import progressbar  # type: ignore[import]
from intelhex import IntelHex  # type: ignore[import]
from serial import Serial  # type: ignore[import]

from mcbootflash.error import (
    BadAddress,
    BadLength,
    ChecksumError,
    McbootflashException,
    UnsupportedCommand,
    VerifyFail,
)
from mcbootflash.protocol import (
    BootCommand,
    BootResponse,
    ChecksumPacket,
    CommandPacket,
    MemoryRangePacket,
    ResponsePacket,
    VersionResponsePacket,
)

logger = logging.getLogger(__name__)

__all__ = ["BootloaderConnection"]

_BOOTLOADER_EXCEPTIONS = {
    BootResponse.UNSUPPORTED_COMMAND: UnsupportedCommand,
    BootResponse.BAD_ADDRESS: BadAddress,
    BootResponse.BAD_LENGTH: BadLength,
    BootResponse.VERIFY_FAIL: VerifyFail,
}

# Is this key always the same? Perhaps generated by MCC during code generation?
# If this key is incorrect, flash write operations will fail silently.
_FLASH_UNLOCK_KEY = 0x00AA0055


@dataclass
class _BootloaderAttributes:
    version: int
    max_packet_length: int
    device_id: int
    erase_size: int
    write_size: int
    program_start: int
    program_end: int

    @property
    def legal_range(self) -> range:
        """Return range of addresses which can be written to."""
        # Final address is legal.
        return range(self.program_start, self.program_end + 1)


class BootloaderConnection(
    Serial,  # type: ignore[misc]
):  # pylint: disable=too-many-ancestors
    """Communication interface to device running MCC 16-bit bootloader.

    BootloaderConnection subclasses serial.Serial from pyserial. When creating a new
    BootloaderConnection instance, you will typically need to specify at least the
    'port' and 'baudrate' arguments from the parent class. See pyserial's documentation
    for detailed information about the serial.Serial class.

    Parameters
    ----------
    quiet : bool (optional)
        If true, don't print a progressbar. False by default.
    """

    def __init__(self, quiet: bool = False, **kwargs: str):
        super().__init__(**kwargs)
        self._quiet = quiet
        self._hexfile: Union[None, IntelHex] = None
        self._bar: Union[None, progressbar.Bar] = None

    def flash(self, hexfile: str) -> None:
        """Flash application firmware.

        Parameters
        ----------
        hexfile : str
            An Intel HEX-file containing application firmware.

        Raises
        ------
        BootloaderError
        UnsupportedCommand
        BadAddress
        BadLength
        VerifyFail
        ChecksumError
        """
        self._hexfile = IntelHex(hexfile)
        logger.info(f"Flashing {hexfile}.")
        boot_attrs = _BootloaderAttributes(
            *self.read_version(), *self._get_memory_address_range()
        )
        self.erase_flash(boot_attrs.erase_size, boot_attrs.legal_range)

        for segment in self._hexfile.segments():
            # Since the MCU uses 16-bit instructions, each "address" in the
            # (8-bit) hex file is actually only half an address. Therefore, we
            # need to divide by two to get the actual address.
            if (segment[0] // 2 in boot_attrs.legal_range) and (
                segment[1] // 2 in boot_attrs.legal_range
            ):
                logger.info(
                    f"Flashing HEX segment {self._hexfile.segments().index(segment)}: "
                    f"{segment[0] // 2:#08x}:{segment[1] // 2:#08x}."
                )
                self._flash_segment(
                    segment,
                    boot_attrs.max_packet_length,
                    boot_attrs.write_size,
                )
            else:
                logger.debug(
                    f"HEX segment {self._hexfile.segments().index(segment)} ignored; "
                    "not in legal range:"
                )
                logger.debug(
                    f"([{segment[0] // 2:#08x}:{segment[1] // 2:#08x}] vs. "
                    f"[{boot_attrs.legal_range[0]:#08x}:"
                    f"{boot_attrs.legal_range[-1]:#08x}])."
                )

        self._self_verify()

    def _flash_segment(
        self,
        segment: Tuple[int, int],
        max_packet_length: int,
        write_size: int,
    ) -> None:
        chunk_size = max_packet_length - CommandPacket.get_size()
        chunk_size -= chunk_size % write_size
        chunk_size //= 2
        total_bytes = segment[1] - segment[0]
        written_bytes = 0
        # If (segment[1] - segment[0]) % write_size != 0, writing the final
        # chunk will fail. However, I have seen no example where it's not,
        # so not adding code to check for now (YAGNI).
        for addr in range(segment[0] // 2, segment[1] // 2, chunk_size):
            hex_low = addr * 2
            hex_high = (addr + chunk_size) * 2
            chunk = self._hexfile[hex_low:hex_high]  # type: ignore[index]
            self._write_flash(addr, chunk.tobinstr())
            self._checksum(addr, len(chunk))
            written_bytes += len(chunk)
            logger.debug(
                f"{written_bytes} bytes written of {total_bytes} "
                f"({written_bytes / total_bytes * 100:.2f}%)."
            )
            if not self._quiet:
                pass
            self._print_progress(written_bytes, total_bytes)

    def _print_progress(self, written_bytes: int, total_bytes: int) -> None:
        if self._bar is None:
            widgets = [
                progressbar.Percentage(),
                " ",
                progressbar.DataSize(),
                " ",
                progressbar.Bar(),
                " ",
                progressbar.Timer(),
            ]
            progress = progressbar.ProgressBar(widgets=widgets)
            self._bar = progress.start(max_value=total_bytes)
        elif written_bytes == total_bytes:
            self._bar.finish()
            self._bar = None
        else:
            self._bar.update(value=written_bytes)

    @staticmethod
    def _check_response(
        command_packet: CommandPacket,
        response_packet: Union[VersionResponsePacket, ResponsePacket],
    ) -> None:
        """Check that response is not an error."""
        if response_packet.command != command_packet.command:
            logger.error("Unexpected response:")
            logger.error(f"Command:  {bytes(command_packet)!r}")
            logger.error(f"Response: {bytes(response_packet)!r}")
            raise McbootflashException("Unexpected response.")

        if isinstance(response_packet, VersionResponsePacket):
            return

        if response_packet.success != BootResponse.SUCCESS:
            logger.error("Command failed:")
            logger.error(f"Command:  {bytes(command_packet)!r}")
            logger.error(f"Response: {bytes(response_packet)!r}")
            raise _BOOTLOADER_EXCEPTIONS[response_packet.success]

    def read_version(self) -> Tuple[int, int, int, int, int]:
        """Read bootloader version and some other useful information.

        Returns
        -------
        version : int
        max_packet_length : int
            The maximum size of a single packet sent to the bootloader,
            including both the command and associated data.
        device_id : int
        erase_size : int
            Flash page size. When erasing flash memory, the number of bytes to
            be erased must align with a flash page.
        write_size : int
            Write block size. When writing to flash, the number of bytes to be
            written must align with a write block.
        """
        read_version_command = CommandPacket(command=BootCommand.READ_VERSION)
        self.write(bytes(read_version_command))
        read_version_response = VersionResponsePacket.from_serial(self)
        self._check_response(read_version_command, read_version_response)
        logger.info("Got bootloader attributes:")
        logger.info(f"Max packet length: {read_version_response.max_packet_length}")
        logger.info(f"Erase size:        {read_version_response.erase_size}")
        logger.info(f"Write size:        {read_version_response.write_size}")
        return (
            read_version_response.version,
            read_version_response.max_packet_length,
            read_version_response.device_id,
            read_version_response.erase_size,
            read_version_response.write_size,
        )

    def _get_memory_address_range(self) -> Tuple[int, int]:
        mem_range_command = CommandPacket(command=BootCommand.GET_MEMORY_ADDRESS_RANGE)
        self.write(bytes(mem_range_command))
        mem_range_response = MemoryRangePacket.from_serial(self)
        self._check_response(mem_range_command, mem_range_response)
        logger.info(
            "Got program memory range: "
            f"{mem_range_response.program_start:#08x}:"
            f"{mem_range_response.program_end:#08x}."
        )

        return mem_range_response.program_start, mem_range_response.program_end

    def erase_flash(
        self,
        erase_size: Union[None, int] = None,
        erase_range: Union[None, range] = None,
        force: bool = False,
        verify: bool = True,
    ) -> None:
        """Erase program memory area.

        Parameters
        ----------
        erase_size: int, optional
            Size of an erase flash page in bytes. Read from connected device if not
            specified.
        erase_range: range, optional
            Address range to erase. By default the entire program memory is erased.
        force : bool, optional
            By default, flash erase will be skipped if no program is detected in the
            program memory area. Setting `force` to True skips program detection and
            erases regardless of whether a program is present or not.
        verify : bool, optional
            The ERASE_FLASH command may fail silently if the `unlock_sequence` field of
            the command packet is incorrect. By default, this method verifies that the
            erase was successful by checking that no application is detected after the
            erase. Set `verify` to False to skip this check.
        """
        erase_size = erase_size or self.read_version()[3]

        if erase_range is None:
            start_address, end_address = self._get_memory_address_range()
        else:
            start_address, end_address = erase_range[0], erase_range[-1]

        if force:
            self._erase_flash(start_address, end_address, erase_size)
            erased = True
        else:
            erased = self._erase_unless_empty(start_address, end_address, erase_size)

        if erased and verify:
            self._verify_erase()

    def _erase_flash(
        self, start_address: int, end_address: int, erase_size: int
    ) -> None:
        erase_flash_command = CommandPacket(
            command=BootCommand.ERASE_FLASH,
            data_length=(end_address - start_address) // erase_size,
            unlock_sequence=_FLASH_UNLOCK_KEY,
            address=start_address,
        )
        logger.info(f"Erasing flash area {start_address:#08x}:{end_address:#08x}.")
        self.write(bytes(erase_flash_command))
        erase_flash_response = ResponsePacket.from_serial(self)
        self._check_response(erase_flash_command, erase_flash_response)

    def _erase_unless_empty(
        self, start_address: int, end_address: int, erase_size: int
    ) -> bool:
        try:
            # Program memory may be empty, which should not be logged as an error.
            logger.disabled = True
            self._self_verify()
        except VerifyFail:
            logger.disabled = False
            logger.info("No application detected, skipping flash erase.")
            return False
        finally:
            logger.disabled = False

        logger.info("Existing application detected, erasing...")
        self._erase_flash(start_address, end_address, erase_size)
        return True

    def _verify_erase(self) -> None:
        try:
            logger.disabled = True
            self._self_verify()
        except VerifyFail:
            logger.disabled = False
            logger.info("No application detected; flash erase successful.")
            return
        finally:
            logger.disabled = False

        logger.error("An application was detected; flash erase failed.")
        logger.error("unlock_sequence field may be incorrect.")
        raise McbootflashException("Flash erase failed.")

    def _write_flash(self, address: int, data: bytes) -> None:
        write_flash_command = CommandPacket(
            command=BootCommand.WRITE_FLASH,
            data_length=len(data),
            unlock_sequence=_FLASH_UNLOCK_KEY,
            address=address,
        )
        logger.debug(f"Writing {len(data)} bytes to {address:#08x}.")
        self.write(bytes(write_flash_command) + data)
        write_flash_response = ResponsePacket.from_serial(self)
        self._check_response(write_flash_command, write_flash_response)

    def _self_verify(self) -> None:
        self_verify_command = CommandPacket(command=BootCommand.SELF_VERIFY)
        self.write(bytes(self_verify_command))
        self_verify_response = ResponsePacket.from_serial(self)
        self._check_response(self_verify_command, self_verify_response)
        logger.info("Self verify OK.")

    def _get_checksum(self, address: int, length: int) -> int:
        calculcate_checksum_command = CommandPacket(
            command=BootCommand.CALC_CHECKSUM,
            data_length=length,
            address=address,
        )
        self.write(bytes(calculcate_checksum_command))
        calculate_checksum_response = ChecksumPacket.from_serial(self)
        self._check_response(calculcate_checksum_command, calculate_checksum_response)
        return calculate_checksum_response.checksum

    def _calculate_checksum(self, address: int, length: int) -> int:
        checksum = 0
        for i in range(address, address + length, 4):
            data = self._hexfile[i : i + 4].tobinstr()  # type: ignore[index]
            checksum += int.from_bytes(data, byteorder="little") & 0xFFFF
            checksum += (int.from_bytes(data, byteorder="little") >> 16) & 0xFF
        return checksum & 0xFFFF

    def _checksum(self, address: int, length: int) -> None:
        """Compare checksums calculated locally and onboard device.

        Parameters
        ----------
        address : int
            Address from which to start checksum.
        length : int
            Number of bytes to checksum.
        """
        checksum1 = self._calculate_checksum(address * 2, length)
        checksum2 = self._get_checksum(address, length)
        if checksum1 != checksum2:
            logger.error(f"Checksum mismatch: {checksum1} != {checksum2}.")
            logger.error("unlock_sequence field may be incorrect.")
            raise ChecksumError
        logger.debug(f"Checksum OK: {checksum1}.")

    def reset(self) -> None:
        """Reset device."""
        reset_command = CommandPacket(command=BootCommand.RESET_DEVICE)
        self.write(bytes(reset_command))
        reset_response = ResponsePacket.from_serial(self)
        self._check_response(reset_command, reset_response)
        logger.info("Device reset.")

    def _read_flash(self) -> None:
        raise NotImplementedError
